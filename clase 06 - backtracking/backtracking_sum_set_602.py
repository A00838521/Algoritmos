# -*- coding: utf-8 -*-
"""Copy of backtracking - sum set - 602.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e0u9zTd6jVBFhJPlMA_DPv77d9_ZvSD8

# Imports:

Importa una libreria para crear la fila: import queue
Importa una libreria para crear copias de objetos: import deepcopy
"""

import queue
import copy

"""#Clase para representar soluciones

Crea una clase ``` Partial_Sol ``` para representar las soluciones parciales como objetos

Como atributos requiere:


1. Un arreglo de tamaño n que representa a la solucion, inicializado en -1
2. Su costo, es decir, cuanto suma. Inicialmente es 0.
3. El indice de su primer elemento indefinido. Inicia en 0.


"""

# Esta clase representa a una solucion
class Partial_Sol:
  def __init__(self, lista, suma, indef_index):
    self.lista = lista
    self.suma = suma
    self.indef_index = indef_index

"""# Extender una solucion parcial

Crea una funcion que extienda soluciones parciales: recibe una solución parcial, y devuelve las soluciones hijas resultado de instanciar una de las variables indefinidas


Debe crear una solucion hija por cada valor en el rango de la variable indefinida.

Ejemplo: [1, -1, -1, -1] tiene como hijas a [1, 0, -1, -1] y [1, 1, -1, -1], que resultan de instanciar la variable del indice 1 con los valores 1 y 0

"""

def instantiate(parent, index, c):
  # Crea soluciones hijas como copias de la solucion parent (usa deepcopy)
  hija1 = copy.deepcopy(parent)
  hija2 = copy.deepcopy(parent)

  # Dale valores a la variable indefinida de cada hija
  hija1.lista[index] = 0
  hija2.lista[index] = 1

  hija1.indef_index += 1
  hija2.indef_index += 1
  # Actualiza el costo de cada solucion hija.
  # En el caso del problema de sum set, actualiza la suma actual acumulada
  hija2.suma += c[index]

  # Devuelve una lista de las soluciones hijas
  return [hija1, hija2]

"""# El problema: sum set

Describe la instancia del problema


*   El conjunto
*   Su tamaño
* El valor de la suma buscada `d`



"""

# Datos que representan a la instancia del sum set problem
conjunto = [1,2,5,6,8]
d = 8
n = len(conjunto)

"""# Backtracking: inicializacion

Usa la clase `Partial_Sol` para crea una solucion inicial que sera la raiz.

Represetala como una lista de n variables indefinidas. Usa -1 como marcador de "indefinido"  
"""

# Usa el constructor de la clase, dandole como parametros:
# 1. Una lista de las variables, todas indefinidas en -1
# 2. Valor inicial de la suma
# 3. Valor de la primer variable indefinida
param = [-1 for i in range(n)]
root_sol = Partial_Sol(param, 0, 0)

"""

Crea una fila vacia usando `queue.Queue()`.

Agrega a la fila la solucion raiz usando `q.put(param)`"""

fila = queue.Queue()
fila.put( root_sol )

"""# Backtraking: ciclo principal

Crea un ciclo que, mientras la fila no este vacia, continue el proceso de:


1.   Extraer la siguiente solucion de la fila
2.   Generar y validas soluciones hijas
3. Agregar las soluciones hijas a la fila
4. Mostrar / guardar las soluciones encontradas que satisfacen el problema sum set


"""

acepted = list()  # lista vacia donde guardaremos soluciones correctas

while not fila.empty():
  # Obten una solucion de la fila (usando q.get() )
  sol_padre = fila.get()

  # Obten el indice de la variable indefinida de la solucion
  indice = sol_padre.indef_index

  # Obten a sus soluciones hijas
  hija1, hija2 = instantiate(sol_padre, indice,conjunto)

  # 4. Verifica si cada hija es valida: lo es si no suma mas de d
  # Si es valida, y requiere puede extenderse mas, agregala a la fila

  if hija1.suma < d and hija1.indef_index < n:
    fila.put(hija1)

  if hija2.suma < d and hija2.indef_index < n:
    fila.put(hija2)

  # Si una solucion hija suma exactamente d, es la solucion buscada
  # Agregala a la lista acepted
  if hija1.suma == d:
    acepted.append(hija1)
  if hija2.suma == d:
    acepted.append(hija2)

"""#Resultados
Finaliza mostrando las soluciones guardadas en `acepted` y de-codificalas: usa los binarios para mostrar cuales miembros del conjunto original participan en la suma

Ejemplo: [0, 0, 0, 0, 1]  es 8
"""

for i in range (len(acepted)):
  print(acepted[i].lista)